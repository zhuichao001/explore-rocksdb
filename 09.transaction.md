## 使用RocksDB Transaction
```
// 基本配置,事务相关操作需要TransactionDB句柄
Options options;
options.create_if_missing = true;
TransactionDBOptions txn_db_options;
TransactionOptions txn_opts;
TransactionDB* txn_db;

// 用支持事务的方式opendb
TransactionDB::Open(options, txn_db_options, kDBPath, &txn_db);

// 创建一个事务上下文, 类似MySQL的start transaction
Transaction* txn = txn_db->BeginTransaction(txn_opts);

// 直接写入新数据
txn->Put("abc", "123");

// ForUpdate写，类似MySQL的select ... for update
s = txn->GetForUpdate(read_options, "abc", &value); 

// 结束事务：提交(或回滚)
txn->Commit();      
//txn->Rollback();
```
## 事务隔离级别
RocksDB 默认只支持 Read Commited 和 Repeatable Read
#### Repeatable Read
```
TransactionOptions txn_opts;
ReadOptions rops;

Transaction* txn = txn_db->BeginTransaction(WriteOptions(), txn_opts);
assert(txn != nullptr);
PrintStatus("txn->put", txn->Put("key1", "value2"));
PrintStatus("txn->Commit", txn->Commit());

// 开启设置snapshot，标识后续该事务 对所有自己更新的key都是独占的
txn_opts.set_snapshot = true;
txn = txn_db->BeginTransaction(WriteOptions(), txn_opts);
assert(txn != nullptr);

// 在其他事务更新之前设置一个snapshot
const Snapshot* snapshot = txn->GetSnapshot();
PrintStatus("txn_db->Put", txn_db->Put(WriteOptions(), "key1", "value3"));

// 普通的读，能够读到value3
PrintStatus("txn->Get", txn->Get(rops, "key1", &value));

// snapshot 读，读到的是value2
rops.snapshot = snapshot;
PrintStatus("txn->Get", txn->Get(rops, "key1", &value));
```

## 事务方式
RocksDB实现了乐观事务和悲观事务(默认是悲观事务)，这两者的不同之处在于冲突检测的位置不同；PessimisticTransactionDB能在冲突概率较高的场景下，提前进行检测，以更早出发冲突事务的回滚而减少开销，而OptimisticTransactionDB在冲突概率不高的场景下能获得较高的性能。
#### 乐观事务
#### 悲观事务

## 事务实现
#### PessimisticTransaction
#### OptimisticTransaction
