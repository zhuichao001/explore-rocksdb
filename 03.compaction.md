#### Compaction
rocksdb的compaction是通过后台线程执行BGWorkCompaction来进行Compaction的调度
<img src="images/compaction.png" width="1160px" />

#### Compaction的触发
- 手动触发，执行CompactFiles调用
- 自动检测，执行MaybeScheduleFlushOrCompaction
  - 在切换WAL(SwitchWAL)时
  - write_buffer(memtable)满时

#### Compaction整体流程
- 1.Prepare key: 从SST文件中读取需要参与Compaciton的K-V数据  
  <img src="images/compaction-prepare.png" width="960px" />
  - 根据每一层的score来取出参与compaction层
  - 利用clean cut算法从层中取出参与compaction的文件
  - 将文件中的key-value边界取出，并做一个边界排序，确认最终的key的边界范围
  - 依据边界范围，按照subcompaction limit 拆分成多个subcompaction ， 创建对应的sub处理的线程执行任务
- 2.Process key: K-V数据的合并、排序，处理不同的key type的操作
  <img src="images/compaction-process.png" width="960px" />
  - 将当前subcompaction的K-V数据取出，维护一个迭代器来进行访问（此时会构造一个堆排序的存储结构，来通过迭代器访问堆顶元素）
  - 合并的过程主要是取到当前internal key的最新的snapshot对应的操作（主要针对put/delete，保留range_deletion）
  - 将合并好的数据返回，交给迭代器一个一个 进行访问，并进行后续的write操作（每访问一个，pop堆顶，并重建堆，再取堆顶元素）
  - 创建输出的文件，并绑定builder 和 writer，方便后续的数据写入

- 3.Write key: 将K-V数据写入对应的Block中


